## 数据结构

### 队列
队列也是一种运算受到限制的线性表
只允许在表的一端进行插入，而在表的另外一端进行删除的操作。

队列和我们日常生活中的排队是一致的，如在售票窗口排队买票，在医院的排队挂号等。

在操作系统中，作业调度和输入/输出管理都有一个排队问题。
先来先服务的策略，打印池中打印作业缓冲区就是队列的典型例子。

***
### 队列的基本运算
- 构造一个空队列
- 入队列
- 出队列
- 读取队列头部元素
- 判断队列是否为空

***

### 队列5个操作的算法

1. 队列的插入
````
EnQueue(QU, x)

if QU.front = (QU.rear + 1 ) % MAXSIZE
    print('overflow')
else
    QU.Q[QU.rear] = x
    QU.rear = (QU.rear + 1) % MAXSIZE  # 指向下一个元素
````
2. 队列的删除
````
DeQueue

if QU.font = QU.rear
    print('underflow')
else
    x = QU.Q[QU.front]
    QU.front = (QU.front + 1)%MAXSIZE
````
3.读取队头元素
````
GetFront

if QU.front = QU.rear
    print('error')
else
    x = QU.Q[QU.front]
````
4.置空队列
````
ClearQueue

QU.front = 0
QU.rear = 0
````
5.判断队空
````
QueueEmpty(QU)

if QU.front = QU.rear
    return True
return False
````

*** 

### 顺序队列 
除了用一片连续的存储空间来存放队列中的元素，还需要设置两个指针front和rear分别
指示队头元素和队尾元素。

它们的初值在初始化时均为0，对于非空队列，front始终指向队头元素，而rear指针总是指向
实际队尾元素的**下一个位置**，为接收新元素做好准备。

***
### 常见的队列
- 单端队列： 先进先出（FIFO）
- 双端队列：
- 循环队列：（可以节约空间, 因为队列的插入会浪费大量空间）
- 优先队列：按照排序字段(例如一个数字类型的权重值)为其排序


优先队列常用来解决调度问题，比如给紧急的任务更高的优先级。

python中，内置的标准库提供了两种实现优先队列的数据结构，分别是heapq和
PriorityQueue。这两种数据结构，其本质是利用堆的数据结构来实现队列。

***
### 队列在实际问题中的应用
- 约瑟夫问题
- 杨辉三角


***

### heap（堆）
堆，对于每一个父节点上的值都小于或者等于子节点的值的二叉树。
此外，一个堆必须是一个完整的二叉树，除了最底层，其他每一层必须是被
完整填满的。

堆，最重要的一个特点就是：首项(heap[0]总是最小的一项)


#heapq 模块
heapq是一个二叉堆的实现，其内部使用内置的list对象，对于列表中的每一个
元素，其满足a[k] <= a[2*k+1] and a[k] <= a[2*k+2], 因此该方法
默认的是一个最小堆，a[0]为队列中的最小元素.


#PriorityQueue 模块
该模块定义的优先级队列，其内部使用了 heapq 模块，所以它的时间复杂度和heapq是相同的。
当一个对象的所有元素都是可比较的时，默认情况下是根据队列中的对象的第一个元素进行
排序，越小的优先级越高，排在越前面。当第一个元素相同时，依次比较后续的元素的大小来进行排序。
由于 PriorityQueue 是继承自 Queue 类，所以很多函数的用法可以直接参照于 Queue 类中的函数。

